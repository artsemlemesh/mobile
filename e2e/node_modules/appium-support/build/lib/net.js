"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadFile = uploadFile;
exports.downloadFile = downloadFile;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _fs = _interopRequireDefault(require("./fs"));

var _url = _interopRequireDefault(require("url"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _jsftp = _interopRequireDefault(require("jsftp"));

var _timing = _interopRequireDefault(require("./timing"));

var _axios = _interopRequireDefault(require("axios"));

var _formData = _interopRequireDefault(require("form-data"));

const DEFAULT_TIMEOUT_MS = 4 * 60 * 1000;

function toAxiosAuth(auth) {
  if (!_lodash.default.isPlainObject(auth)) {
    return null;
  }

  const axiosAuth = {
    username: auth.username || auth.user,
    password: auth.password || auth.pass
  };
  return axiosAuth.username && axiosAuth.password ? axiosAuth : null;
}

async function uploadFileToHttp(localFileStream, parsedUri, uploadOptions = {}) {
  const {
    method = 'POST',
    timeout = DEFAULT_TIMEOUT_MS,
    headers,
    auth,
    fileFieldName = 'file',
    formFields
  } = uploadOptions;
  const {
    href
  } = parsedUri;
  const requestOpts = {
    url: href,
    method,
    timeout,
    maxContentLength: Infinity,
    maxBodyLength: Infinity
  };
  const axiosAuth = toAxiosAuth(auth);

  if (axiosAuth) {
    requestOpts.auth = axiosAuth;
  }

  if (fileFieldName) {
    const form = new _formData.default();
    form.append(fileFieldName, localFileStream);

    if (formFields) {
      let pairs = [];

      if (_lodash.default.isArray(formFields)) {
        pairs = formFields;
      } else if (_lodash.default.isPlainObject(formFields)) {
        pairs = _lodash.default.toPairs(formFields);
      }

      for (const [key, value] of pairs) {
        if (_lodash.default.toLower(key) !== _lodash.default.toLower(fileFieldName)) {
          form.append(key, value);
        }
      }
    }

    requestOpts.headers = Object.assign({}, _lodash.default.isPlainObject(headers) ? headers : {}, form.getHeaders());
    requestOpts.data = form;
  } else {
    if (_lodash.default.isPlainObject(headers)) {
      requestOpts.headers = headers;
    }

    requestOpts.data = localFileStream;
  }

  _logger.default.debug(`Performing ${method} to ${href} with options (excluding data): ` + JSON.stringify(_lodash.default.omit(requestOpts, ['data'])));

  const {
    status,
    statusText
  } = await (0, _axios.default)(requestOpts);

  _logger.default.info(`Server response: ${status} ${statusText}`);
}

async function uploadFileToFtp(localFileStream, parsedUri, uploadOptions = {}) {
  const {
    auth,
    user,
    pass
  } = uploadOptions;
  const {
    hostname,
    port,
    protocol,
    pathname
  } = parsedUri;
  const ftpOpts = {
    host: hostname,
    port: port || 21
  };

  if (auth !== null && auth !== void 0 && auth.user && auth !== null && auth !== void 0 && auth.pass || user && pass) {
    ftpOpts.user = (auth === null || auth === void 0 ? void 0 : auth.user) || user;
    ftpOpts.pass = (auth === null || auth === void 0 ? void 0 : auth.pass) || pass;
  }

  _logger.default.debug(`${protocol} upload options: ${JSON.stringify(ftpOpts)}`);

  return await new _bluebird.default((resolve, reject) => {
    new _jsftp.default(ftpOpts).put(localFileStream, pathname, err => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

async function uploadFile(localPath, remoteUri, uploadOptions = {}) {
  if (!(await _fs.default.exists(localPath))) {
    throw new Error(`'${localPath}' does not exists or is not accessible`);
  }

  const {
    isMetered = true
  } = uploadOptions;

  const parsedUri = _url.default.parse(remoteUri);

  const {
    size
  } = await _fs.default.stat(localPath);

  if (isMetered) {
    _logger.default.info(`Uploading '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size to '${remoteUri}'`);
  }

  const timer = new _timing.default().start();

  if (['http:', 'https:'].includes(parsedUri.protocol)) {
    if (!uploadOptions.fileFieldName) {
      uploadOptions.headers = Object.assign({}, _lodash.default.isPlainObject(uploadOptions.headers) ? uploadOptions.headers : {}, {
        'Content-Length': size
      });
    }

    await uploadFileToHttp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);
  } else if (parsedUri.protocol === 'ftp:') {
    await uploadFileToFtp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);
  } else {
    throw new Error(`Cannot upload the file at '${localPath}' to '${remoteUri}'. ` + `Unsupported remote protocol '${parsedUri.protocol}'. ` + `Only http/https and ftp/ftps protocols are supported.`);
  }

  if (isMetered) {
    _logger.default.info(`Uploaded '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);
  }
}

async function downloadFile(remoteUrl, dstPath, downloadOptions = {}) {
  const {
    isMetered = true,
    auth,
    timeout = DEFAULT_TIMEOUT_MS,
    headers
  } = downloadOptions;
  const requestOpts = {
    url: remoteUrl,
    responseType: 'stream',
    timeout
  };
  const axiosAuth = toAxiosAuth(auth);

  if (axiosAuth) {
    requestOpts.auth = axiosAuth;
  }

  if (_lodash.default.isPlainObject(headers)) {
    requestOpts.headers = headers;
  }

  const timer = new _timing.default().start();
  let responseLength;

  try {
    const writer = _fs.default.createWriteStream(dstPath);

    const {
      data: responseStream,
      headers: responseHeaders
    } = await (0, _axios.default)(requestOpts);
    responseLength = parseInt(responseHeaders['content-length'], 10);
    responseStream.pipe(writer);
    await new _bluebird.default((resolve, reject) => {
      responseStream.once('error', reject);
      writer.once('finish', resolve);
      writer.once('error', e => {
        responseStream.unpipe(writer);
        reject(e);
      });
    });
  } catch (err) {
    throw new Error(`Cannot download the file from ${remoteUrl}: ${err.message}`);
  }

  const {
    size
  } = await _fs.default.stat(dstPath);

  if (responseLength && size !== responseLength) {
    await _fs.default.rimraf(dstPath);
    throw new Error(`The size of the file downloaded from ${remoteUrl} (${size} bytes) ` + `differs from the one in Content-Length response header (${responseLength} bytes)`);
  }

  if (isMetered) {
    const secondsElapsed = timer.getDuration().asSeconds;

    _logger.default.debug(`${remoteUrl} (${(0, _util.toReadableSizeString)(size)}) ` + `has been downloaded to '${dstPath}' in ${secondsElapsed.toFixed(3)}s`);

    if (secondsElapsed >= 2) {
      const bytesPerSec = Math.floor(size / secondsElapsed);

      _logger.default.debug(`Approximate download speed: ${(0, _util.toReadableSizeString)(bytesPerSec)}/s`);
    }
  }
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9uZXQuanMiXSwibmFtZXMiOlsiREVGQVVMVF9USU1FT1VUX01TIiwidG9BeGlvc0F1dGgiLCJhdXRoIiwiXyIsImlzUGxhaW5PYmplY3QiLCJheGlvc0F1dGgiLCJ1c2VybmFtZSIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ1cGxvYWRGaWxlVG9IdHRwIiwibG9jYWxGaWxlU3RyZWFtIiwicGFyc2VkVXJpIiwidXBsb2FkT3B0aW9ucyIsIm1ldGhvZCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiZmlsZUZpZWxkTmFtZSIsImZvcm1GaWVsZHMiLCJocmVmIiwicmVxdWVzdE9wdHMiLCJ1cmwiLCJtYXhDb250ZW50TGVuZ3RoIiwiSW5maW5pdHkiLCJtYXhCb2R5TGVuZ3RoIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicGFpcnMiLCJpc0FycmF5IiwidG9QYWlycyIsImtleSIsInZhbHVlIiwidG9Mb3dlciIsIk9iamVjdCIsImFzc2lnbiIsImdldEhlYWRlcnMiLCJkYXRhIiwibG9nIiwiZGVidWciLCJKU09OIiwic3RyaW5naWZ5Iiwib21pdCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJpbmZvIiwidXBsb2FkRmlsZVRvRnRwIiwiaG9zdG5hbWUiLCJwb3J0IiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImZ0cE9wdHMiLCJob3N0IiwiQiIsInJlc29sdmUiLCJyZWplY3QiLCJGdHAiLCJwdXQiLCJlcnIiLCJ1cGxvYWRGaWxlIiwibG9jYWxQYXRoIiwicmVtb3RlVXJpIiwiZnMiLCJleGlzdHMiLCJFcnJvciIsImlzTWV0ZXJlZCIsInBhcnNlIiwic2l6ZSIsInN0YXQiLCJ0aW1lciIsIlRpbWVyIiwic3RhcnQiLCJpbmNsdWRlcyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJnZXREdXJhdGlvbiIsImFzU2Vjb25kcyIsInRvRml4ZWQiLCJkb3dubG9hZEZpbGUiLCJyZW1vdGVVcmwiLCJkc3RQYXRoIiwiZG93bmxvYWRPcHRpb25zIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VMZW5ndGgiLCJ3cml0ZXIiLCJjcmVhdGVXcml0ZVN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwicmVzcG9uc2VIZWFkZXJzIiwicGFyc2VJbnQiLCJwaXBlIiwib25jZSIsImUiLCJ1bnBpcGUiLCJtZXNzYWdlIiwicmltcmFmIiwic2Vjb25kc0VsYXBzZWQiLCJieXRlc1BlclNlYyIsIk1hdGgiLCJmbG9vciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEsa0JBQWtCLEdBQUcsSUFBSSxFQUFKLEdBQVMsSUFBcEM7O0FBR0EsU0FBU0MsV0FBVCxDQUFzQkMsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSSxDQUFDQyxnQkFBRUMsYUFBRixDQUFnQkYsSUFBaEIsQ0FBTCxFQUE0QjtBQUMxQixXQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNRyxTQUFTLEdBQUc7QUFDaEJDLElBQUFBLFFBQVEsRUFBRUosSUFBSSxDQUFDSSxRQUFMLElBQWlCSixJQUFJLENBQUNLLElBRGhCO0FBRWhCQyxJQUFBQSxRQUFRLEVBQUVOLElBQUksQ0FBQ00sUUFBTCxJQUFpQk4sSUFBSSxDQUFDTztBQUZoQixHQUFsQjtBQUlBLFNBQVFKLFNBQVMsQ0FBQ0MsUUFBVixJQUFzQkQsU0FBUyxDQUFDRyxRQUFqQyxHQUE2Q0gsU0FBN0MsR0FBeUQsSUFBaEU7QUFDRDs7QUFFRCxlQUFlSyxnQkFBZixDQUFpQ0MsZUFBakMsRUFBa0RDLFNBQWxELEVBQTZEQyxhQUFhLEdBQUcsRUFBN0UsRUFBaUY7QUFDL0UsUUFBTTtBQUNKQyxJQUFBQSxNQUFNLEdBQUcsTUFETDtBQUVKQyxJQUFBQSxPQUFPLEdBQUdmLGtCQUZOO0FBR0pnQixJQUFBQSxPQUhJO0FBSUpkLElBQUFBLElBSkk7QUFLSmUsSUFBQUEsYUFBYSxHQUFHLE1BTFo7QUFNSkMsSUFBQUE7QUFOSSxNQU9GTCxhQVBKO0FB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QTBEZSxjQUFlLFNBRHRFLENBQU47QUFFRDs7QUFDRCxNQUFJakIsU0FBSixFQUFlO0FBQ2IsVUFBTTZCLGNBQWMsR0FBR3pCLEtBQUssQ0FBQ0ssV0FBTixHQUFvQkMsU0FBM0M7O0FBQ0FyQyxvQkFBSUMsS0FBSixDQUFXLEdBQUV1QyxTQUFVLEtBQUksZ0NBQXFCWCxJQUFyQixDQUEyQixJQUE1QyxHQUNQLDJCQUEwQlksT0FBUSxRQUFPZSxjQUFjLENBQUNsQixPQUFmLENBQXVCLENBQXZCLENBQTBCLEdBRHRFOztBQUVBLFFBQUlrQixjQUFjLElBQUksQ0FBdEIsRUFBeUI7QUFDdkIsWUFBTUMsV0FBVyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBVzlCLElBQUksR0FBRzJCLGNBQWxCLENBQXBCOztBQUNBeEQsc0JBQUlDLEtBQUosQ0FBVywrQkFBOEIsZ0NBQXFCd0QsV0FBckIsQ0FBa0MsSUFBM0U7QUFDRDtBQUNGO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGZzIGZyb20gJy4vZnMnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgdG9SZWFkYWJsZVNpemVTdHJpbmcgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgRnRwIGZyb20gJ2pzZnRwJztcbmltcG9ydCBUaW1lciBmcm9tICcuL3RpbWluZyc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5cbmNvbnN0IERFRkFVTFRfVElNRU9VVF9NUyA9IDQgKiA2MCAqIDEwMDA7XG5cblxuZnVuY3Rpb24gdG9BeGlvc0F1dGggKGF1dGgpIHtcbiAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXV0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGF4aW9zQXV0aCA9IHtcbiAgICB1c2VybmFtZTogYXV0aC51c2VybmFtZSB8fCBhdXRoLnVzZXIsXG4gICAgcGFzc3dvcmQ6IGF1dGgucGFzc3dvcmQgfHwgYXV0aC5wYXNzLFxuICB9O1xuICByZXR1cm4gKGF4aW9zQXV0aC51c2VybmFtZSAmJiBheGlvc0F1dGgucGFzc3dvcmQpID8gYXhpb3NBdXRoIDogbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZVRvSHR0cCAobG9jYWxGaWxlU3RyZWFtLCBwYXJzZWRVcmksIHVwbG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbWV0aG9kID0gJ1BPU1QnLFxuICAgIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVRfTVMsXG4gICAgaGVhZGVycyxcbiAgICBhdXRoLFxuICAgIGZpbGVGaWVsZE5hbWUgPSAnZmlsZScsXG4gICAgZm9ybUZpZWxkcyxcbiAgfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGNvbnN0IHsgaHJlZiB9ID0gcGFyc2VkVXJpO1xuXG4gIGNvbnN0IHJlcXVlc3RPcHRzID0ge1xuICAgIHVybDogaHJlZixcbiAgICBtZXRob2QsXG4gICAgdGltZW91dCxcbiAgICBtYXhDb250ZW50TGVuZ3RoOiBJbmZpbml0eSxcbiAgICBtYXhCb2R5TGVuZ3RoOiBJbmZpbml0eSxcbiAgfTtcbiAgY29uc3QgYXhpb3NBdXRoID0gdG9BeGlvc0F1dGgoYXV0aCk7XG4gIGlmIChheGlvc0F1dGgpIHtcbiAgICByZXF1ZXN0T3B0cy5hdXRoID0gYXhpb3NBdXRoO1xuICB9XG4gIGlmIChmaWxlRmllbGROYW1lKSB7XG4gICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm0uYXBwZW5kKGZpbGVGaWVsZE5hbWUsIGxvY2FsRmlsZVN0cmVhbSk7XG4gICAgaWYgKGZvcm1GaWVsZHMpIHtcbiAgICAgIGxldCBwYWlycyA9IFtdO1xuICAgICAgaWYgKF8uaXNBcnJheShmb3JtRmllbGRzKSkge1xuICAgICAgICBwYWlycyA9IGZvcm1GaWVsZHM7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChmb3JtRmllbGRzKSkge1xuICAgICAgICBwYWlycyA9IF8udG9QYWlycyhmb3JtRmllbGRzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhaXJzKSB7XG4gICAgICAgIGlmIChfLnRvTG93ZXIoa2V5KSAhPT0gXy50b0xvd2VyKGZpbGVGaWVsZE5hbWUpKSB7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdE9wdHMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIF8uaXNQbGFpbk9iamVjdChoZWFkZXJzKSA/IGhlYWRlcnMgOiB7fSxcbiAgICAgIGZvcm0uZ2V0SGVhZGVycygpKTtcbiAgICByZXF1ZXN0T3B0cy5kYXRhID0gZm9ybTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGhlYWRlcnMpKSB7XG4gICAgICByZXF1ZXN0T3B0cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB9XG4gICAgcmVxdWVzdE9wdHMuZGF0YSA9IGxvY2FsRmlsZVN0cmVhbTtcbiAgfVxuICBsb2cuZGVidWcoYFBlcmZvcm1pbmcgJHttZXRob2R9IHRvICR7aHJlZn0gd2l0aCBvcHRpb25zIChleGNsdWRpbmcgZGF0YSk6IGAgK1xuICAgIEpTT04uc3RyaW5naWZ5KF8ub21pdChyZXF1ZXN0T3B0cywgWydkYXRhJ10pKSk7XG5cbiAgY29uc3Qge3N0YXR1cywgc3RhdHVzVGV4dH0gPSBhd2FpdCBheGlvcyhyZXF1ZXN0T3B0cyk7XG4gIGxvZy5pbmZvKGBTZXJ2ZXIgcmVzcG9uc2U6ICR7c3RhdHVzfSAke3N0YXR1c1RleHR9YCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGVUb0Z0cCAobG9jYWxGaWxlU3RyZWFtLCBwYXJzZWRVcmksIHVwbG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgYXV0aCxcbiAgICB1c2VyLFxuICAgIHBhc3MsXG4gIH0gPSB1cGxvYWRPcHRpb25zO1xuICBjb25zdCB7XG4gICAgaG9zdG5hbWUsXG4gICAgcG9ydCxcbiAgICBwcm90b2NvbCxcbiAgICBwYXRobmFtZSxcbiAgfSA9IHBhcnNlZFVyaTtcblxuICBjb25zdCBmdHBPcHRzID0ge1xuICAgIGhvc3Q6IGhvc3RuYW1lLFxuICAgIHBvcnQ6IHBvcnQgfHwgMjEsXG4gIH07XG4gIGlmICgoYXV0aD8udXNlciAmJiBhdXRoPy5wYXNzKSB8fCAodXNlciAmJiBwYXNzKSkge1xuICAgIGZ0cE9wdHMudXNlciA9IGF1dGg/LnVzZXIgfHwgdXNlcjtcbiAgICBmdHBPcHRzLnBhc3MgPSBhdXRoPy5wYXNzIHx8IHBhc3M7XG4gIH1cbiAgbG9nLmRlYnVnKGAke3Byb3RvY29sfSB1cGxvYWQgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShmdHBPcHRzKX1gKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBuZXcgRnRwKGZ0cE9wdHMpLnB1dChsb2NhbEZpbGVTdHJlYW0sIHBhdGhuYW1lLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdXRoQ3JlZGVudGlhbHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyIC0gTm9uLWVtcHR5IHVzZXIgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhc3MgLSBOb24tZW1wdHkgcGFzc3dvcmRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZ0cFVwbG9hZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNNZXRlcmVkIFt0cnVlXSAtIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWwgdXBsb2FkIHBlcmZvcm1hbmNlXG4gKiAoZS5nLiB0aW1pbmdzIGFuZCBzcGVlZClcbiAqIEBwcm9wZXJ0eSB7QXV0aENyZWRlbnRpYWxzfSBhdXRoXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdHRwVXBsb2FkT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc01ldGVyZWQgW3RydWVdIC0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbCB1cGxvYWQgcGVyZm9ybWFuY2VcbiAqIChlLmcuIHRpbWluZ3MgYW5kIHNwZWVkKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGhvZCBbUE9TVF0gLSBUaGUgSFRUUCBtZXRob2QgdXNlZCBmb3IgZmlsZSB1cGxvYWRcbiAqIEBwcm9wZXJ0eSB7QXV0aENyZWRlbnRpYWxzfSBhdXRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBbMjQwMDAwXSAtIFRoZSBhY3R1YWwgcmVxdWVzdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGhlYWRlcnMgLSBBZGRpdGlvbmFsIHJlcXVlc3QgaGVhZGVycyBtYXBwaW5nXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGZpbGVGaWVsZE5hbWUgW2ZpbGVdIC0gVGhlIG5hbWUgb2YgdGhlIGZvcm0gZmllbGQgY29udGFpbmluZyB0aGUgZmlsZVxuICogY29udGVudCB0byBiZSB1cGxvYWRlZC4gQW55IGZhbHN5IHZhbHVlIG1ha2UgdGhlIHJlcXVlc3QgdG8gdXNlIG5vbi1tdWx0aXBhcnQgdXBsb2FkXG4gKiBAcHJvcGVydHkge0FycmF5PFBhaXI+fE9iamVjdH0gZm9ybUZpZWxkcyAtIFRoZSBhZGRpdGlvbmFsIGZvcm0gZmllbGRzXG4gKiB0byBiZSBpbmNsdWRlZCBpbnRvIHRoZSB1cGxvYWQgcmVxdWVzdC4gVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGNvbnNpZGVyZWQgaWZcbiAqIGBmaWxlRmllbGROYW1lYCBpcyBzZXRcbiAqL1xuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGdpdmVuIGZpbGUgdG8gYSByZW1vdGUgbG9jYXRpb24uIEhUVFAoUykgYW5kIEZUUFxuICogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIFRoZSBwYXRoIHRvIGEgZmlsZSBvbiB0aGUgbG9jYWwgc3RvcmFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVVcmkgLSBUaGUgcmVtb3RlIFVSSSB0byB1cGxvYWQgdGhlIGZpbGUgdG8uXG4gKiBAcGFyYW0gez9GdHBVcGxvYWRPcHRpb25zfEh0dHBVcGxvYWRPcHRpb25zfSB1cGxvYWRPcHRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUgKGxvY2FsUGF0aCwgcmVtb3RlVXJpLCB1cGxvYWRPcHRpb25zID0ge30pIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMobG9jYWxQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvciAoYCcke2xvY2FsUGF0aH0nIGRvZXMgbm90IGV4aXN0cyBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gIH0gPSB1cGxvYWRPcHRpb25zO1xuXG4gIGNvbnN0IHBhcnNlZFVyaSA9IHVybC5wYXJzZShyZW1vdGVVcmkpO1xuICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KGxvY2FsUGF0aCk7XG4gIGlmIChpc01ldGVyZWQpIHtcbiAgICBsb2cuaW5mbyhgVXBsb2FkaW5nICcke2xvY2FsUGF0aH0nIG9mICR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9IHNpemUgdG8gJyR7cmVtb3RlVXJpfSdgKTtcbiAgfVxuICBjb25zdCB0aW1lciA9IG5ldyBUaW1lcigpLnN0YXJ0KCk7XG4gIGlmIChbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHBhcnNlZFVyaS5wcm90b2NvbCkpIHtcbiAgICBpZiAoIXVwbG9hZE9wdGlvbnMuZmlsZUZpZWxkTmFtZSkge1xuICAgICAgdXBsb2FkT3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgXy5pc1BsYWluT2JqZWN0KHVwbG9hZE9wdGlvbnMuaGVhZGVycykgPyB1cGxvYWRPcHRpb25zLmhlYWRlcnMgOiB7fSxcbiAgICAgICAgeydDb250ZW50LUxlbmd0aCc6IHNpemV9XG4gICAgICApO1xuICAgIH1cbiAgICBhd2FpdCB1cGxvYWRGaWxlVG9IdHRwKGZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxQYXRoKSwgcGFyc2VkVXJpLCB1cGxvYWRPcHRpb25zKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmkucHJvdG9jb2wgPT09ICdmdHA6Jykge1xuICAgIGF3YWl0IHVwbG9hZEZpbGVUb0Z0cChmcy5jcmVhdGVSZWFkU3RyZWFtKGxvY2FsUGF0aCksIHBhcnNlZFVyaSwgdXBsb2FkT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBsb2FkIHRoZSBmaWxlIGF0ICcke2xvY2FsUGF0aH0nIHRvICcke3JlbW90ZVVyaX0nLiBgICtcbiAgICAgIGBVbnN1cHBvcnRlZCByZW1vdGUgcHJvdG9jb2wgJyR7cGFyc2VkVXJpLnByb3RvY29sfScuIGAgK1xuICAgICAgYE9ubHkgaHR0cC9odHRwcyBhbmQgZnRwL2Z0cHMgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgaWYgKGlzTWV0ZXJlZCkge1xuICAgIGxvZy5pbmZvKGBVcGxvYWRlZCAnJHtsb2NhbFBhdGh9JyBvZiAke3RvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSBzaXplIGluIGAgK1xuICAgICAgYCR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb3dubG9hZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNNZXRlcmVkIFt0cnVlXSAtIFdoZXRoZXIgdG8gbG9nIHRoZSBhY3R1YWwgZG93bmxvYWQgcGVyZm9ybWFuY2VcbiAqIChlLmcuIHRpbWluZ3MgYW5kIHNwZWVkKVxuICogQHByb3BlcnR5IHtBdXRoQ3JlZGVudGlhbHN9IGF1dGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0IFsyNDAwMDBdIC0gVGhlIGFjdHVhbCByZXF1ZXN0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gaGVhZGVycyAtIFJlcXVlc3QgaGVhZGVycyBtYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBEb3dubG9hZHMgdGhlIGdpdmVuIGZpbGUgdmlhIEhUVFAoUylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlVXJsIC0gVGhlIHJlbW90ZSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBkc3RQYXRoIC0gVGhlIGxvY2FsIHBhdGggdG8gZG93bmxvYWQgdGhlIGZpbGUgdG9cbiAqIEBwYXJhbSB7P0Rvd25sb2FkT3B0aW9uc30gZG93bmxvYWRPcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZG93bmxvYWQgb3BlcmF0aW9uIGZhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZSAocmVtb3RlVXJsLCBkc3RQYXRoLCBkb3dubG9hZE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaXNNZXRlcmVkID0gdHJ1ZSxcbiAgICBhdXRoLFxuICAgIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVRfTVMsXG4gICAgaGVhZGVycyxcbiAgfSA9IGRvd25sb2FkT3B0aW9ucztcblxuICBjb25zdCByZXF1ZXN0T3B0cyA9IHtcbiAgICB1cmw6IHJlbW90ZVVybCxcbiAgICByZXNwb25zZVR5cGU6ICdzdHJlYW0nLFxuICAgIHRpbWVvdXQsXG4gIH07XG4gIGNvbnN0IGF4aW9zQXV0aCA9IHRvQXhpb3NBdXRoKGF1dGgpO1xuICBpZiAoYXhpb3NBdXRoKSB7XG4gICAgcmVxdWVzdE9wdHMuYXV0aCA9IGF4aW9zQXV0aDtcbiAgfVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KGhlYWRlcnMpKSB7XG4gICAgcmVxdWVzdE9wdHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gIH1cblxuICBjb25zdCB0aW1lciA9IG5ldyBUaW1lcigpLnN0YXJ0KCk7XG4gIGxldCByZXNwb25zZUxlbmd0aDtcbiAgdHJ5IHtcbiAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiByZXNwb25zZVN0cmVhbSxcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICB9ID0gYXdhaXQgYXhpb3MocmVxdWVzdE9wdHMpO1xuICAgIHJlc3BvbnNlTGVuZ3RoID0gcGFyc2VJbnQocmVzcG9uc2VIZWFkZXJzWydjb250ZW50LWxlbmd0aCddLCAxMCk7XG4gICAgcmVzcG9uc2VTdHJlYW0ucGlwZSh3cml0ZXIpO1xuXG4gICAgYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzcG9uc2VTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgICAgd3JpdGVyLm9uY2UoJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgICAgd3JpdGVyLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcmVzcG9uc2VTdHJlYW0udW5waXBlKHdyaXRlcik7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkb3dubG9hZCB0aGUgZmlsZSBmcm9tICR7cmVtb3RlVXJsfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZHN0UGF0aCk7XG4gIGlmIChyZXNwb25zZUxlbmd0aCAmJiBzaXplICE9PSByZXNwb25zZUxlbmd0aCkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihkc3RQYXRoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSBmaWxlIGRvd25sb2FkZWQgZnJvbSAke3JlbW90ZVVybH0gKCR7c2l6ZX0gYnl0ZXMpIGAgK1xuICAgICAgYGRpZmZlcnMgZnJvbSB0aGUgb25lIGluIENvbnRlbnQtTGVuZ3RoIHJlc3BvbnNlIGhlYWRlciAoJHtyZXNwb25zZUxlbmd0aH0gYnl0ZXMpYCk7XG4gIH1cbiAgaWYgKGlzTWV0ZXJlZCkge1xuICAgIGNvbnN0IHNlY29uZHNFbGFwc2VkID0gdGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHM7XG4gICAgbG9nLmRlYnVnKGAke3JlbW90ZVVybH0gKCR7dG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9KSBgICtcbiAgICAgIGBoYXMgYmVlbiBkb3dubG9hZGVkIHRvICcke2RzdFBhdGh9JyBpbiAke3NlY29uZHNFbGFwc2VkLnRvRml4ZWQoMyl9c2ApO1xuICAgIGlmIChzZWNvbmRzRWxhcHNlZCA+PSAyKSB7XG4gICAgICBjb25zdCBieXRlc1BlclNlYyA9IE1hdGguZmxvb3Ioc2l6ZSAvIHNlY29uZHNFbGFwc2VkKTtcbiAgICAgIGxvZy5kZWJ1ZyhgQXBwcm94aW1hdGUgZG93bmxvYWQgc3BlZWQ6ICR7dG9SZWFkYWJsZVNpemVTdHJpbmcoYnl0ZXNQZXJTZWMpfS9zYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IHVwbG9hZEZpbGUsIGRvd25sb2FkRmlsZSB9O1xuIl0sImZpbGUiOiJsaWIvbmV0LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
